# 跳表

## 什么是跳表

**跳表**是一种基于**有序链表**的数据结构，通过在原始链表之上建立多层**索引**，实现了快速查找。

我们可以把它想象成现实生活中的“快慢车”或者书籍的“多级目录”：

- **原始链表**：就像一列每站都停的慢车，虽然有序，但查找一个特定元素需要从头遍历到尾，时间复杂度是 $O(n)$ 。
- **多级索引**：跳表在原始链表之上，每隔几个节点就提取一个节点到上一层。这就像建立了一列“快车”，只停靠主要站点。

> 核心思想：空间换时间
> 通过消耗更多的内存空间（建立索引指针），来换取查询效率的大幅提升。

跳表的构建机制：

跳表是通过随机化（概率）来构建的。当插入一个新节点时，会通过“抛硬币”的方式决定该节点是否提升到上一层索引，以及提升几层。这使得跳表在动态插入和删除时不需要像平衡树（AVL、红黑树）那样进行复杂的旋转操作来维持平衡

为了理解跳表，我们先看一个普通的**有序单链表**。如果我们要查找 `19`，需要逐个遍历，效率很低。

**原始有序链表：**

```
Head -> 1 -> 3 -> 7 -> 13 -> 19 -> 21 -> 25 -> NULL
```

**跳表结构：** 跳表通过在上面叠加“索引层”来解决这个问题。每一层索引的数据量大约是下一层的一半。

```
Level 3: Head ---------------------> 13 -------------------------> NULL
          |                           |
Level 2: Head ---------> 7 --------> 13 -----------------> 25 ---> NULL
          |              |            |                    |
Level 1: Head -> 1 -> 3 -> 7 -> 9 -> 13 -> 19 -> 21 -> 23 -> 25 -> NULL
```

- **Level 1**：是最底层的原始链表，包含所有数据。
- **Level 2/3**：是索引层。

> **形象比喻**： 想象你在坐公交车。
> 
> - **Level 1** 是“站站停”的慢车。
> - **Level 2** 是只停大站的快车。
> - **Level 3** 是只停终点站和枢纽站的特快。 聪明的乘客会先坐“特快”接近目的地，再换乘“慢车”到达具体站点。

假设我们要查找数字 **19**。如果不加索引，需要遍历 6 次。 在跳表中，查找路径呈“阶梯状”下沉，红色箭头 `==>` 代表查找路径

```
查找目标: 19

Level 3: Head ==(1)> 13 -------------------------> NULL
                      | (当前值13 < 19，且右侧NULL，下沉)
                      v
Level 2:             13 ==(2)> 25 ---> NULL
                      |        ^ (25 > 19，不能往右了，下沉)
                      v
Level 1:             13 ==(3)> 19 (找到目标！)
```

**路径解析：**

1. 在最高层发现 `13` 小于 `19`，跳到 `13`。
2. 在当前层看下一个是 `25`，大于 `19`，说明目标在 `13` 和 `25` 之间，于是**向下**进入下一层。
3. 在底层向前走一步，命中 `19`。
4. **结果**：只需比较 3 次（时间复杂度从 $O(n)$ 降为 $O(\log n)$）

## 跳表的各项操作复杂度

跳表在各项主要操作上的效率都非常优秀，这也是它能替代平衡树的原因之一

|**操作类型**|**平均时间复杂度**|**最坏时间复杂度**|**空间复杂度**|**说明**|
|---|---|---|---|---|
|**查询 (Search)**|$O(\log n)$|$O(n)$|-|效率媲美二分查找。|
|**插入 (Insert)**|$O(\log n)$|$O(n)$|$O(n)$|包含查找插入位置和更新指针的时间。|
|**删除 (Delete)**|$O(\log n)$|$O(n)$|-|包含查找节点和移除指针的时间。|

- **关于最坏情况 $O(n)$**：这种情况极少发生，只有当随机函数运气极差，导致索引层未能有效建立（例如所有节点都在同一层）时才会出现。在实际工程中，概率极低，通常忽略不计
- **空间复杂度**：由于需要存储多层索引指针，跳表的平均空间复杂度为 $O(n)$

## 跳表和红黑树相比有什么优缺点

这是一个非常经典的面试题，也是架构选型时的重要考量。虽然两者的平均时间复杂度都是 $O(\log n)$，但在实际应用场景中（特别是像 Redis 这样的内存数据库），跳表往往更具优势

### **跳表的优点 (Pros)**

1. **实现简单，易于维护**
    - 红黑树的插入和删除需要处理复杂的**变色**和**旋转**（左旋、右旋）以维持树的平衡，代码实现难度大，容易出错
    - 跳表仅靠随机概率来维持平衡，操作主要是链表的指针修改，逻辑非常直观清晰
2. **区间查找 (Range Query) 性能更优**
    - 这是跳表最大的优势。在红黑树中，找到指定范围的数据需要通过中序遍历，实现相对复杂且不具备局部性
    - 在跳表中，只要找到区间的起始节点，然后顺着底层链表向后遍历即可，效率极高。这也是 Redis 选择跳表来实现 ZSet (Sorted Set) 的核心原因
3. **并发编程更友好**
    - 红黑树在平衡调整时可能涉及整棵树结构的变动，锁的粒度较大
    - 跳表在更新时主要影响局部节点的指针，更容易实现细粒度的锁（甚至无锁编程），适合高并发场景
### **跳表的缺点 (Cons)**

1. **空间占用稍大**
    - 跳表需要存储多级索引指针。虽然红黑树也需要存储左右子节点指针和颜色位，但总体来说，跳表的指针开销略大一些（取决于索引层的概率设置）
2. **依赖随机函数**
    - 跳表的结构稳定性依赖于随机生成器的质量。如果随机分布不均，可能会退化成普通链表。而红黑树通过严格的数学规则保证了最坏情况下的性能

