# SHA系列函数介绍

## 1 SHA-1

SHA-1是由NIST（美国国家标准技术研究所）设计的一种能够产生160比特的散列值的单项散列函数。在《CRYPTREC密码清单》中，SHA-1已经被列入“可谨慎运用的密码清单”，即除了用于保证兼容性的目的以外，其他情况都不推荐使用

## 2 SHA-2

SHA-256、SHA-512等都是由NIST设计的单向散列函数，它们的散列值长度分别为256比特、512比特，这些单向散列函数合起来统称SHA-2。目前，SHA-2还尚未被攻破

SHA-2共包含以下6种版本：

| 名称          | 输出长度 | 内部状态长度   | 备注                 |
| ----------- | ---- | -------- | ------------------ |
| SHA-224     | 224  | 32*8=256 | 将SHA-256的结果截掉32比特  |
| SHA-256     | 256  | 32*8=256 |                    |
| SHA-512/224 | 224  | 64*8=512 | 将SHA-512的结果截掉288比特 |
| SHA-512/256 | 256  | 64*8=512 | 将SHA-512的结果截掉256比特 |
| SHA-384     | 384  | 64*8=512 | 将SHA-512的结果截掉128比特 |
| SHA-512     | 512  | 64*8=512 |                    |

这些变体除了生成摘要的长度、循环运行的次数等一些细微差异之外，基本结构是一致的。了解了SHA-256的计算方式，其它变体也就大致了解了，所以本文主要介绍SHA-256

### 2.1 SHA-256原理介绍

参考文章：

[一文读懂SHA256算法原理及其实现](https://zhuanlan.zhihu.com/p/94619052")

以下的描述当中所用到的标记如下：

1. $\oplus$：按位异或
2. $\wedge$：按位与
3. $\vee$：按位或
4. $\neg$：取反
5. $+$：相加以后对$2^{32}$求余
6. $R^n$：右移n位
7. $S^{n}$：循环右移n位

以上所有操作都是针对32字节

#### 2.1.1 常量初始化

初始化哈希值$H^{(0)}$取自自然数中前面8个素数（2,3,5,7,11,13,17,19）的平方根的小数部分，并且取前面的32位：

$$
\begin{aligned}
H_1^{(0)} &= \text{0x6a09e667}\\
H_2^{(0)} &= \text{0xbb67ae85}\\
H_3^{(0)} &= \text{0x3c6ef372}\\
H_4^{(0)} &= \text{0xa54ff53a}\\
H_5^{(0)} &= \text{0x510e527f}\\
H_6^{(0)} &= \text{0x9b05688c}\\
H_7^{(0)} &= \text{0x1f83d9ab}\\
H_8^{(0)} &= \text{0x5be0cd19}
\end{aligned}
$$

SHA256算法当中还使用到64个常数，记为$K_j,j =0,1,\cdots,63$, 取自自然数中前面64个素数的立方根的小数部分的前32位, 如果用16进制表示, 则相应的常数序列如下：

```
428a2f98 71374491 b5c0fbcf e9b5dba5 3956c25b 59f111f1 923f82a4 ab1c5ed5
d807aa98 12835b01 243185be 550c7dc3 72be5d74 80deb1fe 9bdc06a7 c19bf174
e49b69c1 efbe4786 0fc19dc6 240ca1cc 2de92c6f 4a7484aa 5cb0a9dc 76f988da
983e5152 a831c66d b00327c8 bf597fc7 c6e00bf3 d5a79147 06ca6351 14292967
27b70a85 2e1b2138 4d2c6dfc 53380d13 650a7354 766a0abb 81c2c92e 92722c85
a2bfe8a1 a81a664b c24b8b70 c76c51a3 d192e819 d6990624 f40e3585 106aa070
19a4c116 1e376c08 2748774c 34b0bcb5 391c0cb3 4ed8aa4a 5b9cca4f 682e6ff3
748f82ee 78a5636f 84c87814 8cc70208 90befffa a4506ceb bef9a3f7 c67178f2
```

#### 2.1.2 消息预处理

在计算消息的哈希摘要之前需要对消息进行预处理：

首先对消息进行补码处理: 假设消息$M$的二进制编码长度为$l$位。首先在消息末尾补上一位"1"，然后再补上$k$个"0"，其中𝑘为下列方程的最小非负整数

$$
l + 1 + k \equiv 448 \pmod{512}
$$

举个例子, 以消息"abc"为例显示补位的过程

a，b，c对应的ASCII码和二进制编码分别如下：

| 原始字符 | ASCII码 | 二进制编码    |
| ---- | ------ | -------- |
| a    | 97     | 01100001 |
| b    | 98     | 01100010 |
| c    | 99     | 01100011 |

因此，原始信息“abc”的二进制编码为:`01100001 01100010 01100011`。第一步补位，首先在消息末尾补上一位“1”，结果为：`01100001 01100010 01100011 1`；然后进行第二步的补位，因为$𝑙=24$，可以得到$𝑘=423$，在第一步补位后的消息后面再补423个“0”，结果如下：

![SHA256消息预处理-1](./assets/SHA256消息预处理-1.svg)

最后还需要在上述字节串后面继续进行补码，这个时候补的是原消息“abc”的二进制长度$𝑙=24$的64位二进制表示形式，补完以后的结果如下：

![SHA256消息预处理-2](./assets/SHA256消息预处理-2.svg)

最终补完以后的消息二进制位数长度是512的倍数

这里需要注意的两点是不管原来的消息长度是多少, 即使长度已经满足对512取模后余数是448，补位也必须要进行，这时要填充512位。另外，考虑到最后要将消息长度$l$转换为64位二进制编码，因此，长度的必须小于$2^{64}$，绝大多数情况，这个足够大了

将补码处理后的消息以512位为单位分块为: $M^{(1)},M^{(2)},\cdots,M^{(N)}$，其中第$i$个消息块的前32位表示为: $M_0^{(i)}$，后面32位为: $M_1^{(i)}$，以此类推，最后32位的消息块可表示为：$M_{15}^{(i)}$。我们采用Big endian约定对数据进行编码，即认为第一个字节是最高位字节。因此，对于每一个32位字节，最最左边的比特是最大的比特位

#### 2.1.3 摘要计算主循环

##### 2.1.3.1 主循环中的逻辑函数

**消息扩展函数（用于生成$W_t$）**
$$
\begin{aligned}
\sigma_0(x)&=S^7(x)\oplus S^{18}(x)\oplus R^3(x) \\
\sigma_1(x)&=S^{17}(x)\oplus S^{19}(x)\oplus R^{10}(x)
\end{aligned}
$$
**压缩函数主循环函数（用于计算$T_1,T_2$）**
$$
\begin{aligned}
\Sigma_0(x)&=S^2(x)\oplus S^{13}(x)\oplus S^{22}(x)\\
\Sigma_1(x)&=S^6(x)\oplus S^{11}(x)\oplus S^{25}(x)
\end{aligned}
$$
**逻辑选择函数**
$$
\begin{aligned}
Ch(e,f,g)&=(e\wedge f)\oplus(\neg e\wedge g)\\
Maj(a,b,c)&=(a\wedge b)\oplus(a\wedge c)\oplus(b\wedge c)
\end{aligned}
$$
##### 2.1.3.2 主循环前的准备

在进入 64 轮循环之前，需要准备好**工作变量**和**消息调度数组**

**初始化8个工作变量**

将当前的哈希值（8个32位字）复制到8个工作变量$a,b,c,d,e,f,g,h$中：
$$
\begin{aligned}
a=H_0\\
b=H_1\\
c=H_2\\
d=H_3\\
e=H_4\\
f=H_5\\
g=H_6\\
h=H_7
\end{aligned}
$$
(注：如果是第一个块，$H_0\cdots H_7$为SHA-256的初始常量；如果是后续块，则为上一块的输出哈希值)

**构建消息调度数组$W_t$**

主循环需要64个32位字作为输入（$W_0\cdots W_{63}$）：

* $W_0\cdots W_{15}$：直接来自当前512位消息块的16个字
* $W_{16}\cdots W_{63}$：通过以下公式扩展生成（利用小写$\sigma$函数）：$W_t=\sigma_1(W_{t-2})+W_{t-7}+\sigma_0(W_{t-15})+W_{t-16}$
##### 2.1.3.3 64轮主循环（核心步骤）

主循环执行 **64 次**（$t=0$ 到 63）。每一轮都更新8个工作变量

**计算临时变量$T_1$和$T_2$**
$$
\begin{aligned}
T_1&=h+\Sigma_1(e)+Ch(e,f,g)+K_j+W_j\\
T_2&=\Sigma_0(a)+Maj(a,b,c)
\end{aligned}
$$
(注：所有加法均为模$2^{32}$加法)

**更新工作变量**
$$
\begin{aligned}
h&=g\\
g&=f\\
f&=e\\
e&=d+T_1\\
d&=c\\
c&=b\\
b&=a\\
a&=T_1+T_2
\end{aligned}
$$
循环之后的最终结果即为SHA-256的摘要值

